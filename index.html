<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/DRACOLoader.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

// Scene + camera
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 1000);
camera.position.set(0, 1.5, 4);

// Renderer
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// Controls (helpful to inspect the model)
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// Lights
const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
scene.add(hemi);

const dir = new THREE.DirectionalLight(0xffffff, 2.0);
dir.position.set(5, 10, 5);
dir.castShadow = true;
dir.shadow.camera.near = 0.5;
dir.shadow.camera.far = 50;
dir.shadow.mapSize.set(2048, 2048);
scene.add(dir);

// Placeholder while loading
const placeholder = new THREE.Mesh(
  new THREE.BoxGeometry(0.6, 0.6, 0.6),
  new THREE.MeshStandardMaterial({ color: 0x008800 })
);
placeholder.position.y = 0.3;
placeholder.castShadow = placeholder.receiveShadow = true;
scene.add(placeholder);

// GLTF loader (with optional Draco)
const loader = new GLTFLoader();
const dracoLoader = new DRACOLoader();
// If your GLB is DRACO-compressed, keep this; otherwise it's harmless
dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
loader.setDRACOLoader(dracoLoader);

// Load model (make sure penguin.glb is in the same folder as index.html)
loader.load(
  './penguin.glb',
  (gltf) => {
    console.log('GLTF loaded', gltf);
    const model = gltf.scene || gltf.scenes[0];
    model.traverse((n) => {
      if (n.isMesh) {
        n.castShadow = true;
        n.receiveShadow = true;
        if (n.material) {
          if (n.material.map) n.material.map.encoding = THREE.sRGBEncoding;
          if (Array.isArray(n.material)) {
            n.material.forEach((m) => { if (m.map) m.map.encoding = THREE.sRGBEncoding; });
          }
          n.material.needsUpdate = true;
        }
      }
    });

    scene.add(model);
    scene.remove(placeholder);

    // Fit camera to model
    const box = new THREE.Box3().setFromObject(model);
    if (!box.isEmpty()) {
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI / 180);
      let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
      cameraZ *= 1.6;
      const dirVec = new THREE.Vector3(1, 0.7, 1).normalize();
      camera.position.copy(center).add(dirVec.multiplyScalar(cameraZ));
      camera.near = Math.max(0.01, maxDim / 100);
      camera.far = Math.max(1000, cameraZ * 10);
      camera.updateProjectionMatrix();
      controls.target.copy(center);
      controls.update();
    }

    // Debug materials
    model.traverse((n) => { if (n.isMesh) console.log(n.material); });
  },
  (xhr) => {
    if (xhr.total) {
      console.log(`Model ${(xhr.loaded / xhr.total * 100).toFixed(2)}% loaded`);
    } else {
      console.log(`Model loading: ${xhr.loaded} bytes loaded`);
    }
  },
  (err) => {
    console.error('GLTF load error:', err);
    console.warn('Common causes: wrong file path, CORS, or opening the page via file:// (use a local server).');
  }
);

// Animation loop
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();

// Resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
